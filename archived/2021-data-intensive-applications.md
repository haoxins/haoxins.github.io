---
title: (2021) 数据密集型应用系统设计
description: 江天一色无纤尘, 皎皎空中孤月轮. 江畔何人初见月? 江月何年初照人?
date: 2021-07-06
---

* [数据密集型应用系统设计](https://book.douban.com/subject/30329536/)
  - 原作名: Designing Data-Intensive Applications
  - 出版年: 2018-09-01

## 数据模型与查询语言

```
但是, 如果多对多的关系在数据中很常见呢?
关系模型能够处理简单的多对多关系,
但是随着数据之间的关联越来越复杂,
将数据建模转化为图模型会更加自然.

图由两种对象组成: 顶点 和 边 (也 称为关系)
```

> **关系**: 关联更多, 更深, 即: 更复杂

* Cypher (Neo4j)
* SPARQL
* Datalog (Prolog 子集)

## 数据存储与检索

* **Log**: 一个仅能追加的记录序列

```
日志结构的合并树
(Log-Structured Merge-Tree, 或 LSM-Tree),
它建立在更早期的日志结构文件系统之上.
因此基于合并和压缩排序文件的存储引擎通常都被称为 LSM 存储引擎.
```

```
当查找数据库中某个不存在的键时 LSM-Tree 算法可能很慢:
在确定键不存在之前, 必须先检查内存表,
然后将段一直回溯访问到最旧的段文件
(可能必须从磁盘多次读取).
为了优化这种访问, 存储引擎通常使用额外的布隆过滤器
(布隆过滤器是内存高效的数据结构, 用于近似计算集合的内容.
如果数据库中不存在某个键, 它能够很快告诉你结果,
从而节省了很多对于不存在的键的不必要的磁盘读取)
```

* LSM-tree

```
由于数据按排序存储, 因比可以有效地执行区间查询
(从最小值到最大值扫描所有的键),
并且由于磁盘是顺序写入的,
所以 LSM-tree 可以支持非常高的写入吞吐量.
```

* 对比 B-tree 和 LSM-tree

```
根据经验, LSM-tree 通常对于写人更快,
而 B-tree 被认为对于读取更快.
读取通常在 LSM-tree 上较慢,
因为它们必须在不同的压缩阶段检查多个不同的数据结构和 SSTable.
```

## 数据编码与演化

```
向后兼容:
  较新的代码 可以读取由 旧代码 编写的数据
向前兼容:
  较旧的代码 可以读取由 新代码 编写的数据
```

* OLAP 列式存储
  - 列压缩 位图编码

```
面向列的 存储压缩 和 排序 都非常有助于加速读取.
但是, 它们的缺点是让写人更加困难.
```

* Parquet

* **数据 比 代码 更长久!**
  - 哈哈!

## 数据复制

* 基于语句的复制
  - 如果遇到语句 `UPDATE ... WHERE ... NOW()`
  - 自增列, 触发器, 存储过程, UDF

* 基于预写日志 (WAL) 传输

* 基于行的逻辑日志复制
  - 变更数据捕获 (CDC)

### 复制滞后

## 数据分区

* 读自己的写
  - 用户 A 写入 `主`, 立即读 `从`
  - 写后读一致性/读写一致性

* 单调读

## 事务

## 分布式系统的挑战

## 一致性与共识

## 批处理系统

* 以 UNIX 哲学作类比, 蛮有意思的

```
曾经:
  Online service -> 即时性的 服务 单个用户
  Batch          -> 延迟的 批量 处理多个用户
现在:
  Online service
  Streaming/批流一体

拭目以待!
```

* Bulk Synchronous Parallel (BSP) model

```
这个特点使得基于日志的消息系统更像上一章的批处理过程,
其中派生数据通过可重复的转换过程与输入数据明确分离.
它支持更多的实验性尝试, 也更容易从错误和故障中进行恢复,
从而成为集成数据流的不错选择.
```

```
事件溯源的哲学是小心的 区分事件和命令.
当来自用户的请求第一次到达时,
它最初是一个命令: 此时它可能仍然会失败,
例如因为违反了某些完整性条件.
应用程序必须首先验证它是否可以 执行该命令,
如果验证成功并且命令被接受,
它将变成一个持久且不可变的事件.
```

```
如果你擅长数学, 你可能会说应用状态是事件流对时间的积分得到的,
而变化流是状态对时间的求导得到的.
虽然这个比喻有一定的局限性
(例如状态的二阶导数似乎没有意义),
但可以帮助进一步认知数据.
```

```
事务日志记录了对数据库所做的所有更改.
高速追加是更改日志的唯一方法.
从这个角度来看, 数据库的内容保存了日志中最新记录值的缓存.
日志是事实.
数据库是日志子集的缓存,
该缓存子集恰好是来自日志的每个记录和索引值的最新值.
```

## 流处理系统

```
一个可用的复杂系统总是从可用的简单系统演进而来,
反过来这话也是正确的:
从零开始设计的复杂系统从来都用不了, 也没办法把它变成可用.
      - John Gal <系统学> (1975)
```

## 数据系统的未来

> 看看数年前的书预判未来的技术路线, 别有一番意境
