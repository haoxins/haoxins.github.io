---
title: TAOCP 基本算法 - 计算机程序设计艺术
description: 穷且益坚, 不坠青云之志. 酌贪泉而觉爽, 处涸辙以犹欢.
date: 2021-05-05
---

* [Wiki - The Art of Computer Programming](https://en.wikipedia.org/wiki/The_Art_of_Computer_Programming)
  - [MMIX](https://mmix.cs.hm.edu)

* [计算机程序设计艺术](https://book.douban.com/series/46236)
  - [计算机程序设计艺术 MMIX增补](https://book.douban.com/subject/35170836/)
  - [计算机程序设计艺术 卷1](https://book.douban.com/subject/26681685/)
  - 赠与 @`Gary`

* 高德纳: 我的书专注于永恒的真理
  - 嗯, 还是自夸了

### 这套书对于工程人员, 是否依旧合适?

* 坚持汇编语言的根本原因, 老爷子的书想永恒, 所以没有任何高级语言可以满足~
  - 个人觉得, 除了 位运算相关, 高级语言肯定对读者更友好
  - 但谁知道哪个高级语言可以活得久? C, C++, Rust? (感觉 **C** 机会最大)
  - 话说回来, 就算删掉所有 MMIX 代码, 其实 **TAOCP** 并不会打折
  - 除了极个别章节, 完全不看 MMIX 代码完全没问题
  - 综上, **MMIX 并不减分**

### 概览

> 这本书快递运输中被磕破了, 泪目~

* 先欣赏一下老爷子的初始规划
  - 卷1. 基本算法 第1章: **基本概念**
  - 卷1. 基本算法 第2章: **信息结构**
  - 卷2. 半数值算法 第3章: **随机数**
  - 卷2. 半数值算法 第4章: **算术**
  - 卷3. 排序与查找 第5章: `排序`
  - 卷3. 排序与查找 第6章: `查找`
  - 卷4. 组合算法 第7章: `组合查找`
  - 卷4. 组合算法 第8章: `递归`
  - 卷5. 语法算法 第9章: 词法扫描
  - 卷5. 语法算法 第10章: 语法分析

* 首先, 阅读 `1.3 (MIX) - 1.4`
  - 配合 **(MMIX增补)**, `第一部分 第1章`, `第二部分 第1章`
  - [MMIX](https://mmix.cs.hm.edu)
  - MMIX增补 的排版更加合理, 后置 `排列的应用`
  - `历史与文献`, 不觉得有存在的必要

------------------

## 基本概念

* `算法分析` & `算法理论`

```
算法分析 的一般思想是, 取某个特定的算法, 确定它的定量特性.
偶尔, 我们也要研究一个算法在某种意义下是不是最优的.

至于 算法理论 则完全属于另一主题,
它主要要研究对于计算特定量是否存在可行算法.
```

```
有时我们需要用到复变函数论, 群论, 数论, 概率论等方面更高深的结果.
```

* 调和数, 调和级数

------------------

## 信息结构

### 线性表

* 栈, 队列, 双端队列
* 顺序分配, 链接分配
* 循环链表
  - 可以作为 `栈`, 也可作为 `队列`
  - 多项式计算
* 双向链表
  - 容易 `删除` 节点
  - 容易在节点任意侧 (左 or 右) 插入
  - 电梯调度
* 数组与正交表
  - 高维数组
  - 顺序存储 vs 链接存储
  - 稀疏矩阵

* 对于线性表, 我们可能要执行下列操作
  - 访问表的第k个结点, 查看或改变其字段内容
  - 紧接在第k个结点之前或之后插入一个新结点
  - 删除第k个结点
  - 把两个或多个线性表合并成一个表
  - 把一个线性表划分成两个或多个表
  - 复制一个线性表
  - 确定表中的结点数
  - 根据结点的特定字段, 把表的结点按递增序排序
  - 搜索线性表, 找出一个在某字段上具有特定值的结点

* 拓扑排序

```
拓扑排序问题就是把 偏序 嵌入到 线性序,
即把诸对象排列成一个线性序列, 使得只要 a[j]<a[k], 就有 j<k.
作为拓扑排序的例子, 考虑一个包含科技术语定义的大型术语表.
如果词 w1 的定义直接或间接地依赖 w2, 则称 w2w1.
只要不存在 "循环" 定义, 这个关系就是偏序关系.
在这种情况下, 拓扑排序问题是:
找出一种排列术语表中词汇的方法, 使得所有术语在定义之前都不使用.
```

```
我们理解算法的途径. 不能像读小说那样读算法,
而是建议用样本数据实际运行一两次算法.
之所以这样明确提醒读者, 是因为试运行算法的一个例子,
有助于读者在心中形成各种断言.
对于人们相互之间正确交流算法,
这个观点在心理学上有一个重要的推论:
向别人解释一个算法时,
始终应该明确陈述那些不能由自动机轻易导出的关键性断言.
```

```
求解关于整数的难题时常常用到实数,
而求解关于实数的难题时则常常用到一类更一般的数, 即复数.
复数理论在很多方面比实数理论更简单, 更优美,
不过在本书中将集中讨论实数, 只在实数变得过于复杂时才用复数.
```

* 稀疏矩阵
  - 主元步 (pivot)

```
node 的结构
  ROW:  行下标
  COL:  列下标
  UP:   上元素的链
  LEFT: 左元素的链
  VAL:  值
```

### 树

* 二叉树
  - 前序, 中序, 后序 遍历
  - 线索二叉树 -> 方便遍历

* 树的基本数学性质

* 自由树 (即: 无根树): 定义为无回路的连通图

* 定理 A. 如果 G 是一个图, 则以下陈述等价:
  - (a) G 是自由树;
  - (b) G 是连通的, 但是如果删除任意一条边, 则结果图就不再连通;
  - (c) 如果 V 和 V' 是 G 的不同顶点, 则恰有一条从 V 到 V' 的简单路径.
* 另外, 如果 G 是包含 `n>0` 顶点的有限图, 则以下陈述也与上述定义等价:
  - (d) G 不包含回路, 并且有 `n-1` 条边;
  - (e) G 是连通的, 并且有 `n-1` 条边.

* 定理 K. 如果流程图包含 n 个框 (包括 `开始` 和 `停止`) 和 m 个箭头,
  则可能找到 `m-n+1` 条基本回路,
  和一条从 `开始` 到 `停止` 的基本路径,
  使得从 `开始` 到 `停止` 的每条通路
  (就每条边被遍历的次数而言)
  都等价于该基本路径的一次遍历,
  加上每个基本回路的唯一确定次数的遍历.
  (`基本路径` 和 `基本回路` 可能包含某些按与箭头标记的相反方向遍历的边.
  习惯上, 我们称这种边被遍历 `-1` 次.)
  反之, 对于 `基本路径` 和 `基本回路` 任意遍历,
  如果每条边被遍历的总次数非负,
  并且对应于正遍历次数的顶点和边形成一个连通图,
  则至少存在一条等价的从 `开始` 到 `停止` 的通路.

* 定理 K 可以用来度量高级语言程序的性能.

* 定向树

* 有向图

### 多链结构

* 略过

### 动态存储分配

* 略过

------------------

### MMIX 基础

```
1 short (Wyde)  = 2 bytes
1 int   (Tetra) = 4 bytes
1 long  (Octa)  = 8 bytes
```

* 内存和寄存器
  - 内存 `M[0]`, `M[1]`, ..., `M[2^64 - 1]`
  - `M[x]` = 1 byte
  - 通用寄存器 `$0`, `$1`, ..., `$255`
  - `$x` = 1 long
  - 专用寄存器 `rA`, `rB`, ..., `rZ`, `rBB`, `rTT`, `rWW`, `rXX`, `rYY`, `rZZ`
  - 26 + 6 = 32, `r*` = 1 long

* 指令: 1 int
  - OP, X, Y, Z (1 byte, 1 byte, 1 byte, 1 byte)
  - OP: 操作码, `#20` means `ADD`
  - X, Y, Z: 操作数

```zsh
ADD $X, $Y, $Z # 3 操作数
INCL $X, YZ # 2 操作数
JMP @+4*XYZ # 1 操作数
```

* **Load** 内存数据 -> 寄存器 `$X`

```zsh
LDB $X, $Y, $Z
LDW $X, $Y, $Z
LDT $X, $Y, $Z
LDO $X, $Y, $Z
```

* **算术运算符**

```zsh
ADD $X, $Y, $Z
SUB $X, $Y, $Z
MUL $X, $Y, $Z
DIV $X, $Y, $Z
```

* **浮点运算** `IEEE/ANSI 754`
  - 每一个 long (Octa) 8 bytes: `1 bit` 符号位, `11 bits` 指数位 E, `52 bits` 小数位 F

```zsh
FADD $X, $Y, $Z
FSUB $X, $Y, $Z
FMUL $X, $Y, $Z
FDIV $X, $Y, $Z
```

* **跳转**
  - `JMP @+4*XYZ`
  - `@` 当前位置
  - `@+4*XYZ` 当前位置 `@` 之后的 XYZ 半字 (int, 4 bytes) 位置
  - `+`, 也可以是 `-`

* **转移**
  - `GO $X, $Y, $Z`

### MMIX 汇编语言

* 十进制常量: `123`
* 十六进制常量: `#123`
* 字符常量: `'A'`
* 字符串常量: `"ABC"`

* 指令
  - `标号`: 空白, 符号
  - `操作码`: MMIX 操作码, MMIXAL 伪操作符
  - `表达式`

* 子程序

```
j GREG; m GREG; kk GREG; xk GREG
      GREG @
GoMax SL   kk, $1, 3
      LDO  m, x0, kk
      JMP  1F
3H    LDO  xk, x0, kk
      CMP  t, xk, m
      PBNP t, 5F
4H    SET  m, xk
1H    SR   j, kk, 3
5H    SUB  kk, kk, 8
      PBP  kk, 3B
6H    GO   kk, $0, 0
```

```
SET $1, n; GO $0, GoMax
```

------------------

## MMIX: 新千年的精简指令集计算机

```
MIPS 逐渐 日落西山
ARM 继 移动领域 (Mobile) 之后, 进军 PC, 数据中心
Apple Macbook 转向 ARM
ARM Announces ARM v9 Architecture

RISC-V 发展迅速

精彩纷呈!
```

* [MMIX](https://mmix.cs.hm.edu)
