---
title: Algorithms
description: 西当太白有鸟道, 可以横绝峨眉巅
date: 2020-11-09
---

## 不可解性

* NP (nondeterministic polynomial time)
  - 仅: 解的验证
  - 分解质因数
  - P
* P
* NPC

## 基础算法

* 算法分类
  - 排序
  - 搜索
  - 选择
  - 字符串
  - 向量 & 矩阵
  - 随机
  - 数值计算

* $$ O(n^2) > O(n \lg n) > O(n) > O(\lg n) $$

* 贪心
* 分治
* 回溯
* 动态规划

## 排序

* [Wiki](https://en.wikipedia.org/wiki/Sorting_algorithm)

|         |  稳定  |  原地  |       时间       |      空间      |
| ------- |:-----:|:-----:|:----------------:|:--------------:|
|   冒泡   |   Y   |   Y   | $$ O(n^2) $$     |    O(1)        |
|   插入   |   Y   |   Y   | $$ O(n^2) $$     |    O(1)        |
|   选择   |   N   |   Y   | $$ O(n^2) $$     |    O(1)        |
|   归并   |   Y   |   N   | $$ O(n \lg n) $$ | $$ O(n)    $$  |
|   快速   |   N   |   Y   | $$ O(n \lg n) $$ | $$ O(\lg n) $$ |
|   堆     |   N   |   Y   | $$ O(n \lg n) $$ | $$ O(1)    $$  |
|   桶     |   Y   |   N   |    O(n)          |    O(1)        |

## 查找

* 链表    (**顺序查找**)

* 有序数组 (**二分查找**)
  - 优:
  - 最优的查找效率
  - 最优的空间需求
  - 可进行有序性操作
  - 劣:
  - 插入很慢

* 二叉查找树 (**BST**)
  - 优:
  - 可进行有序性操作
  - 劣:
  - 不保证性能上界
  - 需要额外空间

```
一棵二叉查找树代表了一组键 (及其相应的值) 的集合,
而同一个集合可以用多棵不同的二叉查找树表示.
如果我们将一棵二叉查找树的所有键投影到一条直线上,
保证一个结点的左子树中的键出现在它的左边,
右子树中的键出现在它的右边, 那么我们一定可以得到一条有序的键列.
我们会利用二叉查找树的这种天生的灵活性,
用多棵二叉查找树表示同一组有序的键来实现构建和使用二叉查找树的高效算法.
```

### 平衡二叉查找树 (**红黑树**)

* 优:
  - 最优的查找效率
  - 最优的插入效率
  - 可进行有序性操作
* 劣:
  - 需要额外空间

```
一棵 2-3 查找树或为一棵空树, 或由以下结点组成:

2-结点, 含有一个键 (及其对应的值) 和两条链接,
左链接指向的2-3树中的键都小于该结点,
右链接指向的2-3树中的键都大于该结点.

3-结点, 含有两个键 (及其对应的值) 和三条链接.
左链接指向的2-3树中的键都小于该结点,
中链接指向的2-3树中的键都位于该结点的两个键之间,
右链接指向的2-3树中的键都大于该结点.

将指向一棵空树的链接称为空链接.
```

* 和标准的二叉查找树*由上向下*生长不同,
  *2-3树*的生长是*由下向上*的.

* *2-3树*的分析和二叉查找树的分析大不相同,
  因为我们主要感兴趣的是**最坏情况下**的性能, 而非一般情况.

* 替换*3-结点*
  - *红黑二叉查找树*背后的基本思想是用标准的二叉查找树
    (完全由*2-结点*构成) 和一些额外的信息 (替换*3-结点*) 来表示*2-3树*.
  - 我们将树中的链接分为两种类型:
  - 红链接将两个*2-结点*连接起来构成一个*3-结点*,
    黑链接则是*2-3树*中的普通链接.
  - 确切地说, 我们将*3-结点*表示为由一条左斜的红色链接
    (两个*2-结点*其中之一是另一个的左子结点) 相连的两个*2-结点*,
  - 对于任意的*2-3树*, 只要对结点进行转换,
    我们都可以立即派生出一棵对应的二叉查找树.
  - 我们将用这种方式表示*2-3树*的**二叉查找树**称为*红黑二叉查找树*
    (以下简称为**红黑树**).

* 一种等价的定义
  - **红黑树**的另一种定义是含有红黑链接并满足下列条件的*二叉查找树*:
  - 红链接均为左链接;
  - 没有任何一个结点同时和两条红链接相连;
  - 该树是完美黑色平衡的, 即任意空链接到根结点的路径上的黑链接数量相同.
  - 满足这样定义的*红黑树*和相应的*2-3树*是一一对应的.

* 一一对应
  - 如果我们将一棵*红黑树*中的红链接画平,
    那么所有的空链接到根结点的距离都将是相同的.
  - 如果我们将由*红链接*相连的结点合并, 得到的就是一棵*2-3树*.
  - 相反, 如果将一棵*2-3树*中的*3-结点*画作由红色左链接相连的两个*2-结点*,
    那么不会存在能够和两条红链接相连的结点, 且树必然是完美黑色平衡的,
    因为黑链接即*2-3树*中的普通链接, 根据定义这些链接必然是完美平衡的.
  - 无论我们选择用何种方式去定义它们, **红黑树**都既是*二叉查找树*, 也是*2-3树*.
  - 因此, 如果我们能够在保持一一对应关系的基础上实现*2-3树*的插入算法.
  - 那么我们就能够将两个算法的优点结合起来;
  - *二叉查找树*中简洁高效的**查找**方法和*2-3树*中高效的**平衡插入**算法.

* **红黑树的性质**
  - 研究*红黑树*的性质就是要检查对应的*2-3树*并对相应的*2-3树*进行分析的过程.
  - 我们的最终结论是所有基于*红黑树*的符号表实现都能保证操作的运行时间为对数级别
    (范围查找除外, 它所需的额外时间和返回的键的数量成正比).

* *性能分析*
  - 首先, 无论键的插入顺序如何, 红黑树都几乎是*完美平衡*的.
  - 这从它和*2-3树*的一一对应关系以及*2-3树*的重要性质可以得到.

### 散列表

* 优:
  - 快速查找
  - 快速插入
* 劣:
  - 不可进行有序性操作
  - 需要额外空间

### 索引

* 内存索引, **散列表**
  - 增删改查, 时间复杂度是 O(1)

* 内存索引, **红黑树**
  - 一种平衡二叉查找树
  - 插入, 删除, 查找, 时间复杂度是 O(Logn)

* 磁盘索引, **B+ 树**
  - 多叉树
  - 对相同个数的数据构建索引, B+ 树的高度要低于红黑树
  - 读取 B+ 树索引, 需要的磁盘 IO 次数会更少

### 二叉树

* 堆
  - 一个完全二叉树
  - 每一个节点 `>= (<=)` 所有子节点

* 二叉查找树

* 平衡二叉查找树 (红黑树)

### 判存

* BitMap -> 布隆过滤器 (Bloom Filter)

```
使用 K 个哈希函数, 对同一个数进行哈希
得到 K 个不同的哈希值
分别记作 X1 X2 X3 ... X(k)
把这 K 个值作为位图的 index
将对应的 BitMap[X1] BitMap[X2] BitMap[X3] ... BitMap[X(k)] 都设置成 True (1)
也就是说, 用 K 个二进制位, 来表示一个数的存在

布隆过滤器误判: 只会对存在的情况有误判
如果某个数经过布隆过滤器 判断 不存在, 那这个数真的不存在, 不会发生误判
如果某个数经过布隆过滤器 判断 存在, 这个时候会有可能误判, 有可能并不存在

布隆过滤器 最大的优点: 节省存储空间
```

### 字符/编码

## 图

### 生成树

* 各种最小生成树算法的性能特点
  - `V` 个顶点 `E` 条边, 最坏情况下的增长数量级

|       算法       |  空间  |        时间        |
| ---------------- |:----:|:------------------:|
| 延时的 Prim 算法   |   E   | $$ E\log{E} $$    |
| 即时的 Prim 算法   |   V   | $$ E\log{V} $$    |
| Kruskal          |   E   | $$ E\log{E} $$     |
| Fredman-Tarjan   |   V   | $$ E + V\log{V} $$ |
| Chazelle         |   V   | 非常接近但还没有达到E |
| 理想情况          |   V   |         E?         |

### 路径算法

* [Common used path planning algorithms with animations](https://github.com/zhm-real/PathPlanning)

* Dijkstra
  - 优:
  - 最坏情况下仍有较好性能
  - 劣:
  - 边的权重必须为正

* 拓扑排序
  - 优:
  - 无环图最优算法
  - 劣:
  - 无环加权有向图

* Bellman-Ford
  - 劣:
  - 不能存在负权重环

### 中心性算法

* 度中心性算法
  - 节点的连接数量最高
  - 应用: 受欢迎程度
* 接近中心性算法
  - Wasserman & Faust
  - 调和中心性算法
  - 更容易到达其他节点
  - 应用: 最佳位置
* 中间中心性算法
  - RA-Brandes
  - 哪个节点更能控制节点与群组之间的流
  - 应用: 控制关键点, 致病基因
* PageRank
  - 最重要节点

### 社团发现算法

* 度量算法
  - 三角形计数
  - 聚类系数
  - 应用: 群组稳定性
* 分量算法
  - 连通分量算法, 应用: 分组
  - 强连通分量算法 SCC, 应用: 推荐
* 标签传播算法 LPA
  - 应用: 挖掘共识
* Louvain 模块度算法
  - 应用: Fraud
