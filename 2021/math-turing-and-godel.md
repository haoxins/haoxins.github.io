---
title: 图灵的秘密 & 集异璧之大成 (哥德尔)
description: 寄蜉蝣于天地, 渺沧海之一粟. 哀吾生之须臾, 羡长江之无穷.
date: 2021-05-10
---

* **Gödel**, Escher, Bach: `an Eternal Golden Braid`
  - **GEB**

* [哥德尔 艾舍尔 巴赫](https://book.douban.com/subject/1291204/)
  - 副标题: 集异璧之大成
  - 出版年: 1997-05
  - **不推荐**

* 中译本前后费时 **十余年**
* 译者都是数学和哲学的专家, 还得到 **原作者** 的直接参与
* 使这部译本甚至可看作是一部新的创作

## 图灵的秘密

* [图灵的秘密](https://book.douban.com/subject/10779604/)
  - 副标题: 他的生平, 思想及论文解读

```
有理数有时也称为可通约数,
因为长度被表示成有理数的两个物体总可以重新度量为整数长度,
你只需要将新的度量单位变得足够地小.
```

```
在 1874 年康托尔证明代数数可数的同一篇论文中,
他也证明了实数是不可数的.

整数是可数的, 有理数是可数的, 甚至代数数是可数的.
然而, 实数都是不可数的.

康托尔考虑将实数不可数的性质作为超越数存在的新证据.
(如果超越数不存在, 那么实数就等同于代数数, 从而可数.)
康托尔最终意识到至少有两种无穷:
可数的无穷和不可数的无穷,
即自然数的无穷和连续统的无穷.
自然数, 有理数, 甚至代数数的无限集合都是可数的.
当我们将超越数放进来的时候, 我们突然间就置身在一个完全不同的世界中了.
我们眼前有两种不同的无穷的势:
一种势适用于自然数, 有理数与代数数; 另一种势适用于实数和连续统.
```

```
有限集合与无限集合有很多不同, 其中一个很大的不同就是真子集,
也就是那些与集合自身不相同的子集.
有限集合的真子集总是有较小的基数, 这一点显而易见.
无限集合的真子集也可以有较小的基数.
(例如, 自然数集就是实数集的真子集, 它们的基数是不同的.)
然而在有些情况下, 有些集合的真子集有着与集合本身一样的基数.
这只对无限集合成立.
自然数集是整数集的真子集, 整数集是有理数集的真子集, 有理数集又是代数数集的真子集.
所有这些无限集合都有相同的基数, 它们是等势的.

实数的各种真子集也有可能是相互等势的.
想想 1 与 0 之间的实数.
这些数可以与大于 1 的实数一一对应, 只要把每个数都用 1 除一下就好了.
例如, 0.5 对应 2, 0.25 对应 4, 0.1 对应 10, 0.0001 对应 10000.
这一事实非常有用, 意味着我们可以考察 0 和 1 之间的实数的某些性质,
其结论将适用于所有的实数.
(图灵在他的论文中运用到了这一概念, 康托尔也用到了它.)
```

```
事实上, 连续统与可数集的唯一区别在于, 是否包含超越数.
我们不得不承认, 超越数, 那些 1844 年之前甚至还不能证明其存在性的数,
其实占了实数的绝大部分. 事实上, 它们几乎占满了所有的实数.
```

* 丢番图方程可解性的判定

```
给定一个包含任意个未知数的有理整系数不定方程,
试推导一个过程,
通过有限步运算判定该方程是否存在有理整数解.
```

```
为了分析公理系统, 希尔伯特构思出了 "元数学" 和 "证明论",
能够使用数理逻辑推导其他数学体系结构中的结论.
现在, 这种方法在数学中称为形式化.
在希尔伯特的概念里, 要构建一个形式化的数学系统,
首先要构建定义, 公理和从公理推导至定理的法则.
理想状态下, 生成的系统应该拥有以下四种互相关联的特性:
```

1. **独立性**: *独立性* 是指不存在任何冗余的公理,
                      即没有一个公理可以由其他公理推导出来.
2. **一致性**: *一致性* 是现如今任何公理系统中最重要的特性.
                      推导出来的任何两个定理绝不能相互矛盾!
3. **完备性**: *完备性* 是指能够从已有公理推导出所有为真的公式.
4. **可判定性**

> 对*希尔伯特*来说, 他追寻一个判定过程,
> 用以确定任一给定公式的可证明性的通用方法.

* *哥德尔完备性定理*

```
在所有论域内都正确的逻辑公式是否都可以从公理推导出来,
即便从这个意义上讲, 公理系统是否完备还是个未解决的问题.

这一段指的是这样的一阶逻辑公式,
无论命题函数 (现在称之为谓词) 处于哪个论域,
也无论对之如何解释, 公式总是为真.
这些所谓的"永真"公式, 能不能从公理推导出来?
哥德尔接受了这一挑战, 并在 1929 年的博士论文中证明了
一阶谓词逻辑在该意义下是完备的.

这个定理就是哥德尔完备性定理.
```

```
然而, 数理逻辑显然不是无中生有.
谓词逻辑的一个主要目的, 就是为数字和算术建立坚实的框架和基础.
为了达到这个目的, 就必须将公理加入逻辑系统中, 以便建立数字理论.

那么, 加入这些公理之后, 是不是所有的命题或者其否定式都是可证明的呢?
一阶谓词逻辑在这个更强的意义上是否也是完备的呢?
这有时被称为 "否定的完备性", 而证明它要难得多.
这正是哥德尔紧接着要解决的一个问题.
```

```
这听起来有点像说谎者悖论
("我说的每一句话都是谎话, 包括这句话在内")
的数学形式, 但它其实不是悖论.
这个公式所断言的并不是自己为真或为假, 而是自己不能被证明.
```

```
哥德尔的不完备性定理并没有指出判定过程是不存在的,
它只是证明了这样的判定过程不能确定任意公式是否为真.
充其量, 它只能确定一个公式的可证明性.
```

* *开发一个通用的故障发现算法是不可能的*, 这也是 **阿兰·图灵** 关于
  *可计算数* 和 *判定性问题* 的论文所带来的一个令人不安的推断.

### 可计算数

```
图灵机 -- 这些假想装备的后来叫法 -- 无法计算每个实数.
他设计的机器只能进行有限数量的操作, 通过用数字表示这些操作,
他指出每一台机器唯一地用一个整数来描述,
我们把这个整数称为描述数 (Description Number).
因此, 图灵机是可数的, 可计算数 -- 图灵机可以计算的数 -- 也一定是可数的,
但实数是不可数的 (从康托尔的证明中可知).
可计算数当然包括代数数, 而且还包括 π 和 e 等超越数,
但由于可计算数是可数的, 因而它们根本无法涵盖所有的实数.
```

```
由于图灵机完全由描述数定义,
我们也许有可能创造一台这样的图灵机,
它能够分析这些描述数,
以确定某一特定的机器是否是符合要求的.

图灵证明了这是不可能的:
没有一种判定图灵机是否符合要求的通用过程.
一台图灵机可以分析另一台图灵机的唯一方式,
是一步一步地跟踪机器的操作.
总之, 你必须实际运行一台机器, 以确定它接下来会干什么.
```

* 可计算数可以被简单描述为其小数表达式可在*有限步骤内*计算出来的实数.

* 在图灵的论文中,
  *"步骤"* 并不是指确定数位的实际过程,
  而是指确定数位的方法.

* 图灵断言了*代数数*是*可计算数*,
  随后开始在*超越数*领域讨论这一问题.
  不过, 他说*只有某些超越数是可计算的*.

* *可计算数是可数的*.
  可计算数的*可数性*显示了它们与实数的不同.

```
图灵最初说, 可计算数是可以通过有限步骤计算出来的,
当时听着确实很有道理.
但是, 现在他要通过人类思维的有限性来解读它,
这就提出了关于数学真实性的本质问题.
我们称实数为"实"数, 尽管事实上绝大多数的数从没有人见过.
此外, 图灵还将在论文中指出, 大部分实数都不能通过有限的算法计算出来.
实数究竟在什么意义上存在呢? 这是个哲学问题,
对此, 图灵也只是在其论文的修订版中模糊地提及.
```

* 图灵对自动机和选择机的划分,
  某种程度上使我们联想到划分程序的一个传统方法:
  将程序分为*批处理*的和*交互式*的.

```
图灵试图论证, 图灵机的计算能力等同于一部执行明确定义了数学过程的人类计算者.
因此, 如果算法过程是图灵机不可解的, 那么它对于人类而言也是不可解的.
这个想法后来得名图灵论题, 也称为邱奇-图灵论题.
称其为"论题"是因为它是个过于模糊的概念, 不能接受严格的数学证明.
```

### 判定性问题

```
哥德尔的不完备性定理是关于不可判定命题的,
而判定性问题关心的是, 是否存在通用过程来判定某个给定公式的可证明性.
如果存在通用判定过程, 那么它可以把一个不可判定的命题归为不可证明的.
```

* **戴德金定理**
  - 如果按照以下的方法把实数集合分割成两类 `L` 和 `R`:
  - 1) 每个数只属于两个类中的一类;
  - 2) 每个类至少包含一个数;
  - 3) `L` 中的任意一个数都小于 `R` 中的任意一个数.
  - 则存在一个数 `α`, 满足小于它的所有数都属于 `L` 类,
    大于它的所有数都属于 `R` 类.
    数 `α` 本身可能属于 `L` 或 `R` 中的任意一类.

```
第一次看到这个定理时容易感到迷惑,
但是它描述了有理数和实数之间最基本的区别,
特别是, 实数是如何组成了连续统, 而有理数不能.

想象从左边的负无穷到右边的正无穷有一条数轴,
也可以只考虑这个数轴的一段. 把它分割成两个部分 (这称为戴德金分割).
一些数在左边的线上 (L), 另一些数在右边的线上 (R).
```

```
例如, 你可以在 1.5 处分割这条直线,
因此 L 中的所有数都小于 1.5, R 中的所有数都大于 1.5.
那 1.5 自身呢?
你可以把它放在 L 中, 也可以放在 R 中.
把 1.5 放在 L 中, 它是 L 中的最大数, R 中没有最小数.
换句话说, R 中没有一个比其余的数字都小的数.
另一方面, 把 1.5 放在 R 中, 它是 R 中的最小数, L 中没有最大数.

在 2 的平方根处分割这条直线.
如果这条数轴仅由有理数组成,
那么 L 中的所有数都小于 2 的平方根,
R 中的所有数都大于 2 的平方根.
因为 2 的平方根不是有理数, 它既不属于 L, 也不属于 R.
此外, L 中没有最大数, R 中也没有最小数.
这条直线在 2 的平方根处出现间断.

然而, 如果这条数轴是由实数组成的, 则 2 的平方根必须属于 L 或者 R.
你无法定义一个实数的分割, 使得这个分割点既不属于 L 也不属于 R.
这就是为什么实数可以组成连续统, 而有理数不能的原因.

如果我们用 "可计算数" 替换 "实数", 那么一般形式表示的戴德金定理就不成立了.
可计算数不能组成连续统, 因为你可以在一个非可计算数处做戴德金分割.
这个数也许太复杂 (也就是太随机) 而难以用算法定义,
或者你也可以定义这个数, 例如, 由每个可计算数中的一个数位构成的数, 但无法计算它.
这个分割把可计算数分成两个部分, 使得 L 中没有最大数, R 中也没有最小数.
```

* **λ 演算**

```
在那时, 数学家们希望理解有效可计算性这个模糊的概念.
为了知道数值计算的局限及能力,
有必要用形式系统化的方式来定义函数,
也就是说用符号, 字符串和确定性规则来定义.
最好的方法是什么呢?
这种方法能否表明这些函数能够充分概括有效可计算性?
```

* 对*连续统*的设想

* 我们有了一个对*可计算数*的不怎么繁琐的数学定义,
  这或许会让我们稍感满足,
  但是依然很难弥补我们从哲学角度对**连续统**问题*茫然无措*的迷失感.

* 不管你对图灵的概念或原理有多深的了解,
  都不会对你构建一台真正的计算机有所帮助.

* 作为计算机时代的产物,
  马蒂亚塞维奇用现代编程语言的专业术语描述他的机器的工作原理,
  并阐述了它们和程序设计语句的关系.
  他证明了 **"图灵机不能判定某一类丢番图方程是否有解, 更不要说任意丢番图方程了"**.

------------------

## GEB - 哥德尔 - 集异璧

* 这本书稿不胜荣幸地成为商务印书馆历史上第一批用计算机排制版的学术译著.
  - 科普, 不是学术

> 呃, 全书不少错别字 :(

* **形式系统!**

* *欧几里德*给出了*五条公设*作为几何学这个无穷级大厦的*地基*
  - *前四条*公设相当**优美简洁**
  - 1) 一条直线段可以联接两个点.
  - 2) 一条直线上任何一条直线段可以无限延伸.
  - 3) 给定一条直线段, 可以以一个端点为圆心, 以此线段为半径做一个圆.
  - 4) 一切直角都彼此相等.
  - 然而*第五条*却*不那么雅致*
  - 5) 如果两条直线与第三条直线相交时,
       在第三条直线的某一侧三条线所夹的内角之和小于两个直角的和,
       则那两条直线沿着这一侧延伸足够长之后必然相交.

* **完全性**
  - 每个能由系统中的概念表示出来的真陈述都是系统中的定理
* **一致性**
  - 每个定理经解释后都成为真的 (在某个想象的世界里).
* **完全性**
  - 所有真的 (在某个想象的世界里) 且可表示成系统中的良构符号串的陈述都是定理.

### 康托尔

* 康托尔要表明的是:
  - 如果建立了一个实数 `"登记表"`, 它就不可避免地要把某些实数拒之门外
  - 因此, 实际上 `"一个完全的实数登记表"` 这个观念本身就是自相矛盾的.

* 必须看到, 这不仅适用于有限的登记表, 而且也适用于无穷长的登记表.
  这个结果比下述命题深刻得多,
  "实数有无穷多个, 因此显然不能列在一个有限长的登记表中".
  康托尔的结果的实质在于说明了存在(至少)两种不同类型的无穷
  - 一种无穷描述了在一个无穷长的登记表中能有多少表目,
  - 另一种无穷描述了实数的数量(即一条线或线段上点的数量)
  - 因此后者"更大", 其理由是实数不能被塞进一个具有
    前一种无穷的长度的表之中.

* 让我们看看为什么**康托尔**的论证中涉及了**对角线**这个词.

* 我们只考虑 `0` 和 `1` 之间的实数就够了.
  为了进行论证, 先假设能够给出一个无穷长的表,
  其中每个正整数 `N` 对应于 `0` 和 `1` 之间的一个实数 `r(N)`,
  而且 `0` 和 `1` 之间的每个实数都将出现在表中的某个位置上.
  由于实数都能写成无穷小数, 我们可以设想这张表的开始部分可能是这样的:
  - r(1): .`1` 4 1 5 9 2 6 5 3 ...
  - r(2): .3 `3` 3 3 3 3 3 3 3 ...
  - r(3): .7 1 `8` 2 8 1 8 2 8 ...
  - r(4): .4 1 4 `2` 1 3 5 6 2 ...
  - r(5): .5 0 0 0 `0` 0 0 0 0 ...

* 其中对角线上的数字用黑体印出了: `1`, `3`, `8`, `2`, `0` ....
  现在要用这些数字来构造一个特殊的实数 `d`, `d` 在 `0` 和`1` 之间,
  但我们将发现它不在表内.
* 为了构造 `d`, 我们依次取出对角线上的数字,
  然后把其中的每一个都设成别的什么数字.
  当在这样得到的数字序列前加上小数点之后, 你就得到了 `d`.
* 当然把一个数字改成别的什么数字会有许多种办法,
  相应地可以得到许多不同的 `d`.
  例如, 设我们从每个对角线上的数字中减去 `1`
  (并约定 `0` 减 `1` 得 `9`). 那么我们得到的 `d` 将是;
  `.02719 ...`
* 这时, 根据我们的构造方式, 有:
  - `d` 的第 `1` 位不同于 `r(1)` 的第 `1` 位;
  - `d` 的第 `2` 位不同于 `r(2)` 的第 `2` 位;
  - `d` 的第 `3` 位不同于 `r(3)` 的第 `3` 位;
  - ... 如此等等. 因此, 我们有
  - `d` 不同于 `r(1)`;
  - `d` 不同于 `r(2)`;
  - `d` 不同于 `r(3)`;
  - ... 如此等等.
  - 换句括说, `d` 不在表中!
